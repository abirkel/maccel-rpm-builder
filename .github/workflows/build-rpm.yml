name: Build RPM Packages

on:
  repository_dispatch:
    types: [build-for-kernel]
  workflow_dispatch:
    inputs:
      kernel_version:
        description: 'Kernel version (e.g., 6.11.5-300.fc41.x86_64)'
        required: true
        type: string
      fedora_version:
        description: 'Fedora version (e.g., 41)'
        required: true
        type: string
      force_rebuild:
        description: 'Force rebuild even if packages exist'
        required: false
        type: boolean
        default: false

env:
  KERNEL_VERSION: ${{ github.event.client_payload.kernel_version || inputs.kernel_version }}
  FEDORA_VERSION: ${{ github.event.client_payload.fedora_version || inputs.fedora_version }}
  TRIGGER_REPO: ${{ github.event.client_payload.trigger_repo || 'manual' }}
  FORCE_REBUILD: ${{ github.event.client_payload.force_rebuild || inputs.force_rebuild || false }}

jobs:
  validate-and-check:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      maccel_version: ${{ steps.version.outputs.maccel_version }}
      existing_release: ${{ steps.check.outputs.existing_release }}
      package_info: ${{ steps.check.outputs.package_info }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: |
          chmod +x scripts/*.sh
          ls -la scripts/

      - name: Validate kernel version format
        run: |
          # Source error handling library
          source ./scripts/error-handling.sh
          setup_error_handling "validate-kernel" "/tmp"
          
          # Validate kernel version with comprehensive error handling
          if ! validate_kernel_version "$KERNEL_VERSION"; then
            log_critical "Kernel version validation failed" "version=$KERNEL_VERSION"
            exit 2
          fi
          
          log_info "Kernel version validation passed" "version=$KERNEL_VERSION"

      - name: Detect maccel version
        id: version
        run: |
          # Source error handling library
          source ./scripts/error-handling.sh
          setup_error_handling "detect-version" "/tmp"
          
          log_info "Starting maccel version detection"
          
          # Validate maccel source access first
          if ! validate_maccel_source_access 3 10; then
            log_critical "Cannot access maccel source repository" "retries=3"
            exit 2
          fi
          
          # Use the dedicated version detection script with error handling
          if ! MACCEL_VERSION=$(execute_with_error_handling "./scripts/detect-maccel-version.sh detect" "Detecting maccel version" 60 2); then
            log_critical "Failed to detect maccel version" "script=detect-maccel-version.sh"
            exit 2
          fi
          
          if ! COMMIT_HASH=$(execute_with_error_handling "./scripts/detect-maccel-version.sh commit-hash" "Getting source commit hash" 30 2); then
            log_warning "Failed to get source commit hash, using fallback" "fallback=unknown"
            COMMIT_HASH="unknown"
          fi
          
          log_info "Version detection completed successfully" "version=$MACCEL_VERSION, commit=$COMMIT_HASH"
          
          echo "maccel_version=$MACCEL_VERSION" >> $GITHUB_OUTPUT
          echo "source_commit=$COMMIT_HASH" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Check for existing packages
        id: check
        run: |
          # Source error handling library
          source ./scripts/error-handling.sh
          setup_error_handling "check-packages" "/tmp"
          
          log_info "Starting package existence check" "kernel=$KERNEL_VERSION, maccel=${{ steps.version.outputs.maccel_version }}, force_rebuild=$FORCE_REBUILD"
          
          # Use the dedicated package detection script with error handling
          if CHECK_RESULT=$(execute_with_error_handling "./scripts/check-existing-packages.sh check '$KERNEL_VERSION' '${{ steps.version.outputs.maccel_version }}' '$FORCE_REBUILD'" "Checking for existing packages" 120 2); then
            # Check the actual result, not just exit code
            if [[ "$CHECK_RESULT" == "BUILD_SKIP" ]]; then
              log_info "Packages are up-to-date, skipping build"
              echo "should_build=false" >> $GITHUB_OUTPUT
              
              # Get existing package information with error handling
              if PACKAGE_INFO=$(execute_with_error_handling "./scripts/check-existing-packages.sh info '$KERNEL_VERSION' '${{ steps.version.outputs.maccel_version }}'" "Getting package information" 60 2); then
                EXISTING_RELEASE=$(echo "$PACKAGE_INFO" | jq -r '.release_tag' 2>/dev/null || echo "unknown")
                echo "existing_release=$EXISTING_RELEASE" >> $GITHUB_OUTPUT
                
                # Store package info for later use (escape for GitHub Actions)
                echo "package_info<<EOF" >> $GITHUB_OUTPUT
                echo "$PACKAGE_INFO" >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT
                
                # Output package URLs for reference
                log_info "Existing package URLs:"
                echo "$PACKAGE_INFO" | jq -r '.packages[] | "- \(.name): \(.url)"' 2>/dev/null || log_warning "Could not parse package URLs"
              else
                log_error "Failed to get existing package information"
                echo "existing_release=unknown" >> $GITHUB_OUTPUT
              fi
            else
              log_info "Build is required (packages don't exist or source has changed)"
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "existing_release=" >> $GITHUB_OUTPUT
            fi
          else
            log_error "Package check failed completely"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "existing_release=" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

  build-packages:
    needs: validate-and-check
    if: needs.validate-and-check.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for Sigstore keyless signing
    strategy:
      matrix:
        package: [kmod-maccel, maccel]
      fail-fast: false  # Continue building other packages if one fails
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: chmod +x scripts/*.sh

      - name: Set up build environment
        run: |
          # Source error handling library
          source ./scripts/error-handling.sh
          setup_error_handling "setup-build-${{ matrix.package }}" "./packages"
          
          log_info "Setting up build environment" "package=${{ matrix.package }}, kernel=$KERNEL_VERSION, fedora=$FEDORA_VERSION"
          
          # Validate build dependencies first
          if ! validate_build_dependencies; then
            log_critical "Build dependencies validation failed"
            exit 2
          fi
          
          # Set up build environment with timeout and retry
          if ! execute_with_error_handling "./scripts/setup-build-environment.sh '$KERNEL_VERSION' '$FEDORA_VERSION' '${{ needs.validate-and-check.outputs.maccel_version }}'" "Setting up build environment" 1800 2; then
            log_critical "Build environment setup failed" "package=${{ matrix.package }}"
            exit 2
          fi
          
          log_info "Build environment setup completed successfully" "package=${{ matrix.package }}"

      - name: Build ${{ matrix.package }} package
        run: |
          # Source error handling library
          source ./scripts/error-handling.sh
          setup_error_handling "build-${{ matrix.package }}" "./packages"
          
          log_info "Starting package build" "package=${{ matrix.package }}, kernel=$KERNEL_VERSION, maccel=${{ needs.validate-and-check.outputs.maccel_version }}"
          
          # Create packages directory
          mkdir -p "./packages"
          
          # Build package with comprehensive error handling and extended timeout
          if ! execute_with_error_handling "./scripts/build-packages.sh '${{ matrix.package }}' '$KERNEL_VERSION' '${{ needs.validate-and-check.outputs.maccel_version }}' '$FEDORA_VERSION' './packages'" "Building ${{ matrix.package }} package" 2400 1; then
            log_critical "Package build failed" "package=${{ matrix.package }}"
            
            # Analyze build failure if build logs exist
            if [[ -f "./packages/build.log" ]]; then
              analyze_build_failure "./packages/build.log" "${{ matrix.package }}"
            fi
            
            # Check for common build artifacts to help with debugging
            log_info "Build directory contents for debugging:"
            ls -la "./packages/" || true
            ls -la "$HOME/rpmbuild/BUILD/" || true
            
            exit 2
          fi
          
          log_info "Package build completed successfully" "package=${{ matrix.package }}"

      - name: Sign and verify packages
        run: |
          echo "Running package signing and verification process..."
          ./scripts/sign-packages.sh full-process "./packages"
          
          # List all generated files for verification
          echo "Generated files:"
          ls -la packages/

      - name: Upload package artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.package }}-${{ env.KERNEL_VERSION }}
          path: |
            packages/*.rpm
            packages/*.sig
            packages/*.crt
            packages/checksums.txt
            packages/build-info.json
            packages/signing-summary.json
            packages/PACKAGE_VERIFICATION.md
            packages/verification-report.txt
            packages/sigstore-info.txt

  create-release:
    needs: [validate-and-check, build-packages]
    if: needs.validate-and-check.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for creating releases
      id-token: write  # Required for Sigstore verification
    outputs:
      release_tag: ${{ steps.release.outputs.release_tag }}
      release_url: ${{ steps.release.outputs.release_url }}
      package_urls: ${{ steps.release.outputs.package_urls }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: chmod +x scripts/*.sh

      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Prepare release assets
        id: prepare
        run: |
          echo "Preparing release assets..."
          
          # Create release directory
          mkdir -p release-assets
          
          # Collect all RPM files and metadata from artifacts
          find . -name "*.rpm" -exec cp {} release-assets/ \;
          find . -name "checksums.txt" -exec cp {} release-assets/ \; 2>/dev/null || true
          find . -name "build-info.json" -exec cp {} release-assets/ \; 2>/dev/null || true
          
          # Collect signing and verification files
          find . -name "*.sig" -exec cp {} release-assets/ \; 2>/dev/null || true
          find . -name "*.crt" -exec cp {} release-assets/ \; 2>/dev/null || true
          find . -name "signing-summary.json" -exec cp {} release-assets/ \; 2>/dev/null || true
          find . -name "PACKAGE_VERIFICATION.md" -exec cp {} release-assets/ \; 2>/dev/null || true
          find . -name "verification-report.txt" -exec cp {} release-assets/ \; 2>/dev/null || true
          find . -name "sigstore-info.txt" -exec cp {} release-assets/ \; 2>/dev/null || true
          
          cd release-assets
          
          # Generate comprehensive checksums if not already present
          if [[ ! -f checksums.txt ]]; then
            echo "Generating checksums for all RPM packages..."
            sha256sum *.rpm > checksums.txt
          fi
          
          # Extract architecture from kernel version for metadata
          ARCH="x86_64"  # Default
          if [[ "$KERNEL_VERSION" =~ \.([^.]+)$ ]]; then
            ARCH="${BASH_REMATCH[1]}"
          fi
          
          # Generate enhanced build metadata if not already present
          if [[ ! -f build-info.json ]]; then
            echo "Generating build metadata..."
            cat > build-info.json << EOF
          {
            "kernel_version": "$KERNEL_VERSION",
            "maccel_version": "${{ needs.validate-and-check.outputs.maccel_version }}",
            "maccel_commit": "${{ needs.validate-and-check.outputs.source_commit }}",
            "fedora_version": "$FEDORA_VERSION",
            "architecture": "$ARCH",
            "build_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "trigger_repo": "$TRIGGER_REPO",
            "packages": [
              {
                "name": "kmod-maccel",
                "version": "${{ needs.validate-and-check.outputs.maccel_version }}-1.fc$FEDORA_VERSION",
                "filename": "kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc$FEDORA_VERSION.$ARCH.rpm",
                "type": "kernel-module",
                "description": "Kernel module for maccel mouse acceleration driver"
              },
              {
                "name": "maccel",
                "version": "${{ needs.validate-and-check.outputs.maccel_version }}-1.fc$FEDORA_VERSION",
                "filename": "maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc$FEDORA_VERSION.$ARCH.rpm",
                "type": "userspace-tools",
                "description": "Userspace CLI tools and configuration for maccel"
              }
            ]
          }
          EOF
          fi
          
          # List all assets for verification
          echo "Release assets prepared:"
          ls -la
          
          # Output asset information for next step
          echo "rpm_count=$(ls -1 *.rpm | wc -l)" >> $GITHUB_OUTPUT
          echo "total_size=$(du -sh . | cut -f1)" >> $GITHUB_OUTPUT

      - name: Create GitHub release
        id: release
        run: |
          cd release-assets
          
          RELEASE_TAG="kernel-${KERNEL_VERSION}-maccel-${{ needs.validate-and-check.outputs.maccel_version }}"
          RELEASE_NAME="Kernel ${KERNEL_VERSION} - maccel ${{ needs.validate-and-check.outputs.maccel_version }}"
          
          echo "Creating release: $RELEASE_TAG"
          echo "Release name: $RELEASE_NAME"
          
          # Get upstream release notes for maccel version
          UPSTREAM_NOTES=""
          if UPSTREAM_NOTES=$(curl -s "https://api.github.com/repos/Gnarus-G/maccel/releases/tags/v${{ needs.validate-and-check.outputs.maccel_version }}" | jq -r '.body' 2>/dev/null) && [[ "$UPSTREAM_NOTES" != "null" && -n "$UPSTREAM_NOTES" ]]; then
            echo "Found upstream release notes for maccel ${{ needs.validate-and-check.outputs.maccel_version }}"
          else
            # Try without 'v' prefix
            if UPSTREAM_NOTES=$(curl -s "https://api.github.com/repos/Gnarus-G/maccel/releases/tags/${{ needs.validate-and-check.outputs.maccel_version }}" | jq -r '.body' 2>/dev/null) && [[ "$UPSTREAM_NOTES" != "null" && -n "$UPSTREAM_NOTES" ]]; then
              echo "Found upstream release notes for maccel ${{ needs.validate-and-check.outputs.maccel_version }}"
            else
              echo "No upstream release notes found for maccel ${{ needs.validate-and-check.outputs.maccel_version }}"
              UPSTREAM_NOTES=""
            fi
          fi
          
          # Create comprehensive release notes
          cat > release_notes.md << EOF
          # RPM Packages for maccel ${{ needs.validate-and-check.outputs.maccel_version }}
          
          Built for **Kernel ${KERNEL_VERSION}** on **Fedora ${FEDORA_VERSION}**
          
          ## ðŸ“¦ Package Information
          
          | Package | Version | Type | Description |
          |---------|---------|------|-------------|
          | \`kmod-maccel\` | ${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION} | Kernel Module | maccel driver for kernel ${KERNEL_VERSION} |
          | \`maccel\` | ${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION} | CLI Tools | Userspace tools and configuration |
          
          ## ðŸ”§ Build Details
          
          - **Kernel Version**: \`${KERNEL_VERSION}\`
          - **Maccel Version**: \`${{ needs.validate-and-check.outputs.maccel_version }}\`
          - **Source Commit**: \`${{ needs.validate-and-check.outputs.source_commit }}\`
          - **Build Date**: \`$(date -u +%Y-%m-%d)\`
          - **Architecture**: \`$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2)\`
          - **Triggered by**: \`${TRIGGER_REPO}\`
          
          ## ðŸ“¥ Installation
          
          ### Quick Install
          \`\`\`bash
          # Download both packages
          wget https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm
          wget https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm
          
          # Install packages
          sudo dnf install ./kmod-maccel-*.rpm ./maccel-*.rpm
          \`\`\`
          
          ### Blue Build Integration
          \`\`\`yaml
          # In your Blue Build recipe
          rpm:
            install:
              - https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm
              - https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm
          \`\`\`
          
          ## ðŸ” Verification
          
          ### Package Integrity
          \`\`\`bash
          # Download checksums
          wget https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/checksums.txt
          
          # Verify packages
          sha256sum -c checksums.txt
          \`\`\`
          
          ### Package Signatures (Sigstore Keyless)
          
          Packages are signed using **Sigstore keyless signing** with GitHub OIDC identity.
          
          \`\`\`bash
          # Install cosign (Sigstore CLI)
          curl -sLO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          
          # Download signature and certificate files
          wget https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm.sig
          wget https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm.crt
          
          # Verify package signature
          cosign verify-blob --signature kmod-maccel-*.rpm.sig --certificate kmod-maccel-*.rpm.crt \\
            --certificate-identity-regexp ".*" \\
            --certificate-oidc-issuer-regexp ".*" \\
            kmod-maccel-*.rpm
          \`\`\`
          
          **Benefits of Sigstore:**
          - ðŸ” No key management required
          - ðŸŒ Cryptographic proof via GitHub OIDC identity  
          - ðŸ“‹ Transparency through public Rekor audit log
          - â° Short-lived certificates (no long-term key compromise)
          
          ### Comprehensive Verification Guide
          For detailed verification instructions, see: [PACKAGE_VERIFICATION.md](https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/PACKAGE_VERIFICATION.md)
          
          ### Package Information
          \`\`\`bash
          # Query package details
          rpm -qip kmod-maccel-*.rpm
          rpm -qip maccel-*.rpm
          \`\`\`
          
          ## ðŸ“‹ Package Contents
          
          ### kmod-maccel Package
          - Kernel module: \`maccel.ko\` for kernel ${KERNEL_VERSION}
          - Module configuration and loading scripts
          - Kernel version-specific dependencies
          
          ### maccel Package
          - CLI binary: \`/usr/bin/maccel\`
          - Udev rules: \`/etc/udev/rules.d/99-maccel.rules\`
          - Configuration files and documentation
          - Dependency on \`kmod-maccel\` package
          
          ## ðŸ”— Stable Download URLs
          
          These URLs are permanent and suitable for automated consumption:
          
          - **kmod-maccel**: https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm
          - **maccel**: https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2).rpm
          - **checksums**: https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/checksums.txt
          - **build-info**: https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/build-info.json
          - **verification-guide**: https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/PACKAGE_VERIFICATION.md
          - **sigstore-info**: https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/sigstore-info.txt
          
          **Signature Files:**
          - kmod-maccel signatures: \`.sig\` and \`.crt\` files for Sigstore verification
          - maccel signatures: \`.sig\` and \`.crt\` files for Sigstore verification
          EOF
          
          # Append upstream release notes if available
          if [[ -n "$UPSTREAM_NOTES" ]]; then
            cat >> release_notes.md << EOF
          
          ## ðŸ“ Upstream Release Notes (maccel ${{ needs.validate-and-check.outputs.maccel_version }})
          
          $UPSTREAM_NOTES
          EOF
          fi
          
          # Create the release with all assets
          echo "Creating GitHub release with assets..."
          
          # Prepare asset list - include all available files
          ASSETS="*.rpm checksums.txt build-info.json"
          
          # Add Sigstore signature files if they exist
          for sig_file in *.sig; do
            [[ -f "$sig_file" ]] && ASSETS="$ASSETS $sig_file"
          done
          for crt_file in *.crt; do
            [[ -f "$crt_file" ]] && ASSETS="$ASSETS $crt_file"
          done
          
          # Add other signing/verification files if they exist
          [[ -f signing-summary.json ]] && ASSETS="$ASSETS signing-summary.json"
          [[ -f PACKAGE_VERIFICATION.md ]] && ASSETS="$ASSETS PACKAGE_VERIFICATION.md"
          [[ -f verification-report.txt ]] && ASSETS="$ASSETS verification-report.txt"
          [[ -f sigstore-info.txt ]] && ASSETS="$ASSETS sigstore-info.txt"
          
          echo "Assets to upload: $ASSETS"
          
          gh release create "$RELEASE_TAG" \
            --title "$RELEASE_NAME" \
            --notes-file release_notes.md \
            --latest=false \
            $ASSETS
          
          # Output release information
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${RELEASE_TAG}"
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          
          # Generate package URLs JSON for output
          ARCH=$(echo "$KERNEL_VERSION" | grep -oP '\.(x86_64|aarch64)$' | cut -d. -f2)
          PACKAGE_URLS=$(cat << EOF
          [
            {
              "name": "kmod-maccel",
              "filename": "kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.${ARCH}.rpm",
              "url": "https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/kmod-maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.${ARCH}.rpm"
            },
            {
              "name": "maccel",
              "filename": "maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.${ARCH}.rpm",
              "url": "https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/maccel-${{ needs.validate-and-check.outputs.maccel_version }}-1.fc${FEDORA_VERSION}.${ARCH}.rpm"
            }
          ]
          EOF
          )
          
          echo "package_urls<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGE_URLS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "âœ… Release created successfully: $RELEASE_TAG"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Report build success
        run: |
          # Source notification system
          source ./scripts/build-notifications.sh
          init_notification_system "build-success" "./packages"
          
          # Get build metadata from build-info.json if available
          BUILD_METADATA="{}"
          if [[ -f "./release-assets/build-info.json" ]]; then
            BUILD_METADATA=$(cat "./release-assets/build-info.json")
          fi
          
          # Report successful build with comprehensive information
          ./scripts/build-notifications.sh success \
            "${{ steps.release.outputs.release_tag }}" \
            "${{ steps.release.outputs.release_url }}" \
            '${{ steps.release.outputs.package_urls }}' \
            "$BUILD_METADATA"
          
          log_info "Build success notification completed" "release=${{ steps.release.outputs.release_tag }}"

  report-existing:
    needs: validate-and-check
    if: needs.validate-and-check.outputs.should_build == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: chmod +x scripts/*.sh

      - name: Report existing packages
        run: |
          # Source notification system
          source ./scripts/build-notifications.sh
          init_notification_system "existing-packages" "/tmp"
          
          # Get package information
          PACKAGE_INFO='${{ needs.validate-and-check.outputs.package_info }}'
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-and-check.outputs.existing_release }}"
          
          # Report existing packages with comprehensive information
          ./scripts/build-notifications.sh existing \
            "${{ needs.validate-and-check.outputs.existing_release }}" \
            "$RELEASE_URL" \
            "$PACKAGE_INFO"
          
          log_info "Existing packages notification completed" "release=${{ needs.validate-and-check.outputs.existing_release }}"

  report-failure:
    needs: [validate-and-check, build-packages, create-release]
    if: always() && (failure() || cancelled())
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: chmod +x scripts/*.sh

      - name: Report build failure
        run: |
          # Source notification system
          source ./scripts/build-notifications.sh
          init_notification_system "build-failure" "/tmp"
          
          # Determine failure type and details
          ERROR_TYPE="UNKNOWN_ERROR"
          ERROR_MESSAGE="Build process failed"
          ERROR_DETAILS=""
          TROUBLESHOOTING=""
          
          # Check validation job status
          if [[ "${{ needs.validate-and-check.result }}" == "failure" ]]; then
            ERROR_TYPE="VALIDATION_ERROR"
            ERROR_MESSAGE="Input validation or package check failed"
            ERROR_DETAILS="The build failed during the validation phase. This could be due to invalid kernel version format, maccel source access issues, or GitHub API problems."
            TROUBLESHOOTING="- Verify kernel version format: X.Y.Z-REL.fcN.ARCH; Check maccel repository accessibility; Ensure GitHub token has proper permissions; Verify network connectivity"
          fi
          
          # Check build job status
          if [[ "${{ needs.build-packages.result }}" == "failure" ]]; then
            ERROR_TYPE="BUILD_ERROR"
            ERROR_MESSAGE="RPM package building failed"
            ERROR_DETAILS="The build failed during the package compilation phase. This could be due to missing dependencies, compilation errors, or system resource issues."
            TROUBLESHOOTING="- Check build dependencies (rpm-build, kernel-devel, rust); Verify sufficient disk space and memory; Review build logs for specific compilation errors; Ensure kernel headers are available for target version"
          fi
          
          # Check release job status
          if [[ "${{ needs.create-release.result }}" == "failure" ]]; then
            ERROR_TYPE="RELEASE_ERROR"
            ERROR_MESSAGE="GitHub release creation failed"
            ERROR_DETAILS="The build completed successfully but failed to create the GitHub release. This could be due to permissions issues or GitHub API problems."
            TROUBLESHOOTING="- Verify GitHub token has write permissions to repository; Check GitHub API status and rate limits; Ensure release tag doesn't already exist; Review GitHub Actions permissions settings"
          fi
          
          # Check for cancellation
          if [[ "${{ needs.validate-and-check.result }}" == "cancelled" || "${{ needs.build-packages.result }}" == "cancelled" || "${{ needs.create-release.result }}" == "cancelled" ]]; then
            ERROR_TYPE="BUILD_CANCELLED"
            ERROR_MESSAGE="Build process was cancelled"
            ERROR_DETAILS="The build was cancelled before completion. This could be due to timeout, manual cancellation, or system issues."
            TROUBLESHOOTING="- Check for build timeout (default: 1 hour); Verify system resources and stability; Review workflow logs for cancellation reason; Retry the build if cancellation was unintentional"
          fi
          
          # Create detailed error report
          ./scripts/build-notifications.sh error-report "$ERROR_TYPE" "/tmp" "/tmp/error-report.json"
          
          # Report the failure with comprehensive information
          ./scripts/build-notifications.sh failure \
            "$ERROR_TYPE" \
            "$ERROR_MESSAGE" \
            "$ERROR_DETAILS" \
            "$TROUBLESHOOTING"
          
          log_error "Build failure notification completed" "type=$ERROR_TYPE"
          
          # Upload error report as artifact for debugging
          if [[ -f "/tmp/error-report.json" ]]; then
            echo "Error report created at /tmp/error-report.json"
          fi

      - name: Upload error report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: error-report-${{ github.run_id }}
          path: |
            /tmp/error-report.json
            /tmp/maccel-build-*.log
          retention-days: 30